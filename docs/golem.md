# G.O.L.E.M: The myth, the package, the legend

G.O.L.E.M: Goal oriented, logic encapsulating modeler. A noble endeavor for the logic minded.
This package is for building, deploying, and maintaining golems.

## Overview

## Pieces of a Golem

### Core

> Definition: The primary processing system of a golem. i.e. the seat of intelligence. Can only have 1 per golem.

#### Purpose of the Core

Determines the types of logos encapsulation a golem can perform. The core determines the extent to which a golem can adapt, learn, or remember. Semantic processing, world modeling, relational reasoning, agent capabilities, multi-modal support or aggregation, location mapping, etc... are all aspects of a golems primary purpose.

### Framework

> Definition: The construction, deployment, and maintenance systems of a golem. Can only have 1 per golem.

#### Purpose of the Framework

All feedback, as well as the primary drives/goals, reside herein. A golems framework determines the types of feedback (neg/pos/both i.e. pain/pleasure) it can receive, and, in some instances, generates part, or most, of the golems feedback internally. It also handles routing inbetween all model type modules (regardless of location, and model type module is structurally analogous to some part of the neocortex)

### Shell

> Definition: The housing, and I/O systems of a golem. A golem only has an aggregate shell which can be composed of many different distinct, or interconnected sub-shells.

#### Purpose of the Shell

The interactive bits. Data processing models for entry into/manipulation by the core. A motor controller, and corresponding motor are part of the same shell, with the controller being a model that gets hooked into the golem for construction deployment, and maintenance, and the motor being well defined mapping between commands and external actions. An eye or pair of eyes is a shell. Having a pair of eyes in one place, then another pair somewhere else would require adding two distinct eye shells to the golem.
Paired vs individual shell support is determined by the Core and Framework types. Imagine having a stationary mainframe body with potential avatar bodies, and a mobile body without potential avatars. The various modeling systems within the core would thus determine what types of inputs a golem can support, how many of each type, how they get aggregated into semantic wholes, the numbers, and sizes of item location maps, the info compression rate from shell to core, and many other critical elements.